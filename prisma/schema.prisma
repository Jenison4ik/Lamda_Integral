// =======================
// Datasource & Generator
// =======================

datasource db {
  provider = "sqlite"
}

generator client {
  provider = "prisma-client-js"
}

// =======================
// Models
// =======================

model User {
  id          Int           @id @default(autoincrement())
  telegramId  BigInt        @unique
  username    String?
  lastSeen    DateTime?
  createdAt   DateTime      @default(now())

  sessions    QuizSession[]

  @@map("users")
}

model QuizSession {
  id                   Int              @id @default(autoincrement())
  userId               Int
  difficulty           String
  showAnswersAfterEach Boolean          @default(false) // true: после каждого, false: в конце
  startedAt            DateTime         @default(now())
  finishedAt           DateTime?

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  questions       SessionQuestion[]  // связи с вопросами (порядок: вопрос, затем ответы после каждого / в конце)
  answers         SessionAnswer[]

  @@map("quiz_sessions")
}

// Вопрос — самостоятельная единица. Ответы (AnswerOption) идут к вопросу; в квизе: вопрос, затем ответы после каждого (или в конце).
model Question {
  id            Int              @id @default(autoincrement())
  difficulty    String           // "easy", "medium", "hard"
  text          String           // Текст вопроса (интеграл)
  createdAt     DateTime         @default(now())

  answerOptions AnswerOption[]
  sessionLinks  SessionQuestion[]  // техническая обратная связь для Prisma

  @@map("questions")
}

// Связь сессии с вопросами: сессия ссылается на вопросы с сохранением порядка (как answerOptions у Question).
model SessionQuestion {
  sessionId  Int
  questionId Int
  orderIndex Int   // порядок в сессии (0, 1, 2, ...)

  session    QuizSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question   Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([sessionId, questionId])
  @@map("session_questions")
}

model AnswerOption {
  id          Int              @id @default(autoincrement())
  questionId  Int
  text        String           // Текст варианта ответа
  isCorrect   Boolean          @default(false)

  question    Question         @relation(fields: [questionId], references: [id], onDelete: Cascade)
  chosenIn     SessionAnswer[]

  @@map("answer_options")
}

model SessionAnswer {
  sessionId       Int
  questionId      Int          // Для уникальности и быстрых запросов
  chosenOptionId  Int          // ID выбранного варианта ответа
  answeredAt      DateTime     @default(now())

  session         QuizSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  chosenOption    AnswerOption @relation(fields: [chosenOptionId], references: [id], onDelete: Cascade)
  // Вопрос можно получить через chosenOption.question, но questionId нужен для:
  // 1. Уникальности ответа на вопрос в сессии [sessionId, questionId]
  // 2. Быстрых запросов без JOIN
  // 3. Валидации (проверка, что chosenOption принадлежит questionId)

  @@id([sessionId, questionId])
  @@map("session_answers")
}
