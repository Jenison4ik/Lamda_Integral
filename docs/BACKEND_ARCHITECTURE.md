# Архитектура бэкенда Lambda Integral

## Тип архитектуры: **Hexagonal Architecture (Ports and Adapters)**

Также известна как:
- **Ports and Adapters Architecture**
- **Clean Architecture** (многослойная вариация)
- **Onion Architecture** (похожий подход)

---

## Что такое Hexagonal Architecture?

**Hexagonal Architecture (Гексагональная архитектура)** — это архитектурный паттерн, предложенный Алистером Кокберном в 2005 году. Основная идея заключается в изоляции бизнес-логики приложения от внешних зависимостей (HTTP-фреймворков, баз данных, внешних API) через абстракции, называемые **портами (Ports)** и **адаптерами (Adapters)**.

### Концептуальная модель:

```
        ┌─────────────────────────────┐
        │   Внешние адаптеры          │
        │   (HTTP, CLI, WebSocket)    │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │   ПОРТЫ (Ports)             │
        │   Интерфейсы для            │
        │   взаимодействия            │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │   ЯДРО ПРИЛОЖЕНИЯ            │
        │   (Application Core)         │
        │   • Бизнес-логика            │
        │   • Доменные модели          │
        │   • Правила                  │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │   ПОРТЫ (Ports)             │
        │   Интерфейсы для            │
        │   данных                    │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │   Внутренние адаптеры        │
        │   (БД, файлы, внешние API)   │
        └─────────────────────────────┘
```

**Ключевая особенность**: Ядро приложения (бизнес-логика) находится в центре и не зависит от внешних технологий. Все взаимодействия происходят через порты, а конкретные реализации (адаптеры) можно легко заменять.

### Визуализация "шестиугольника":

Название "hexagonal" (шестиугольная) не означает, что должно быть ровно 6 сторон. Это метафора: приложение можно представить как шестиугольник, где каждая сторона — это точка взаимодействия с внешним миром (HTTP, CLI, WebSocket, БД, файлы, внешние API и т.д.).

```
                    ┌─────────┐
                   ╱  HTTP    ╲
                  ╱  Adapter  ╲
                 │             │
        ┌────────┤   ЯДРО     ├────────┐
        │ WebSocket│ ПРИЛОЖЕНИЯ │  CLI  │
        │ Adapter │             │Adapter│
        └────────┤             ├────────┘
                 │             │
                  ╲  Database ╱
                   ╲  Adapter ╱
                    └─────────┘
```

---

## ASCII-арт диаграмма

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ВНЕШНИЙ МИР (External World)                    │
│                                                                         │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐             │
│  │   Telegram   │    │   Web App    │    │   Admin UI   │             │
│  │     Bot      │    │  (Frontend)  │    │              │             │
│  └──────┬───────┘    └──────┬───────┘    └──────┬───────┘             │
│         │                   │                    │                     │
└─────────┼───────────────────┼────────────────────┼─────────────────────┘
          │                   │                    │
          │ HTTP/Webhook      │ HTTP/REST          │ HTTP/REST
          │                   │                    │
          ▼                   ▼                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    СЛОЙ АДАПТЕРОВ (Adapters Layer)                      │
│                    ⚠️  ЗАМЕНИМЫЙ СЛОЙ  ⚠️                               │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │              HTTP Адаптеры (Vercel Functions)                │      │
│  │                                                              │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │      │
│  │  │api/bot.ts│  │api/auth.ts│  │api/users.ts│ │api/hello.ts│ │      │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │      │
│  │       │             │              │              │          │      │
│  │       └─────────────┴──────────────┴──────────────┘          │      │
│  │                          │                                   │      │
│  │                    Только HTTP-специфика:                    │      │
│  │                    • VercelRequest                           │      │
│  │                    • VercelResponse                          │      │
│  │                    • Разбор query/body                       │      │
│  │                    • Формирование ответа                     │      │
│  └──────────────────────────┼───────────────────────────────────┘      │
│                             │                                          │
│  ┌──────────────────────────┴───────────────────────────────────┐      │
│  │  🔄 ЛЕГКО ЗАМЕНИТЬ НА:                                        │      │
│  │  ┌─────────────────────────────────────────────────────┐    │      │
│  │  │  Express.js Routes:                                  │    │      │
│  │  │  app.post('/api/auth', async (req, res) => {        │    │      │
│  │  │    const result = await loginAdmin(req.body);        │    │      │
│  │  │    res.status(result.status).json(result.data);      │    │      │
│  │  │  });                                                 │    │      │
│  │  └─────────────────────────────────────────────────────┘    │      │
│  │                                                              │      │
│  │  Или Fastify, Koa, Hono, и т.д.                            │      │
│  └──────────────────────────────────────────────────────────────┘      │
└───────────────────────────────────┬────────────────────────────────────┘
                                     │
                                     │ ControllerResult<T>
                                     │ (platform-agnostic)
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              СЛОЙ ПРИЛОЖЕНИЯ (Application Layer / Ports)                │
│              ✅ НЕЗАВИСИМ ОТ ПЛАТФОРМЫ ✅                                │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │                    Контроллеры (Controllers)                  │      │
│  │                                                              │      │
│  │  ┌──────────────────┐  ┌──────────────────┐                │      │
│  │  │auth.controller.ts│  │user.controller.ts│                │      │
│  │  │                  │  │                  │                │      │
│  │  │ • loginAdmin()   │  │ • createUser()   │                │      │
│  │  │ • verifyAdmin()  │  │                  │                │      │
│  │  │ • ensureTelegram │  │                  │                │      │
│  │  │   User()         │  │                  │                │      │
│  │  └────────┬─────────┘  └────────┬─────────┘                │      │
│  │           │                      │                           │      │
│  │           └──────────┬───────────┘                           │      │
│  │                      │                                        │      │
│  │              Возвращают: ControllerResult<T>                  │      │
│  │              { status: number, data: T }                      │      │
│  └──────────────────────┼───────────────────────────────────────┘      │
│                         │                                              │
│  ┌──────────────────────┴───────────────────────────────────────┐      │
│  │              Обработка ошибок (Error Handling)                │      │
│  │                                                              │      │
│  │  ┌────────────────────────────────────────────────────┐     │      │
│  │  │  lib/errors/app.errors.ts                           │     │      │
│  │  │  • AppError                                         │     │      │
│  │  │  • ValidationError                                  │     │      │
│  │  │  • UnauthorizedError                                │     │      │
│  │  │  • UniqueConstraintError                            │     │      │
│  │  └────────────────────────────────────────────────────┘     │      │
│  └──────────────────────────────────────────────────────────────┘      │
└───────────────────────────────────┬────────────────────────────────────┘
                                     │
                                     │ Service calls
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              ДОМЕННЫЙ СЛОЙ (Domain Layer / Business Logic)               │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │                    Сервисы (Services)                         │      │
│  │                                                              │      │
│  │  ┌──────────────────┐  ┌──────────────────┐                │      │
│  │  │ auth.service.ts  │  │ user.service.ts  │                │      │
│  │  │                  │  │                  │                │      │
│  │  │ • ensureTelegram │  │ • create()       │                │      │
│  │  │   User()         │  │ • getById()      │                │      │
│  │  └────────┬─────────┘  │ • getByTelegramId│                │      │
│  │           │             └────────┬─────────┘                │      │
│  │           │                      │                           │      │
│  │  ┌────────┴─────────┐  ┌────────┴─────────┐                │      │
│  │  │telegram-auth.    │  │question.service. │                │      │
│  │  │service.ts        │  │ts                │                │      │
│  │  │                  │  │                  │                │      │
│  │  │ • verifyInitData │  │ • getQuestions() │                │      │
│  │  └──────────────────┘  └──────────────────┘                │      │
│  │                                                              │      │
│  │  ✅ Чистая бизнес-логика                                    │      │
│  │  ✅ НЕ знает про HTTP, Request, Response                    │      │
│  │  ✅ Работает с DTO и доменными типами                       │      │
│  └──────────────────────┼───────────────────────────────────────┘      │
└─────────────────────────┼──────────────────────────────────────────────┘
                          │
                          │ Prisma calls
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│            ИНФРАСТРУКТУРНЫЙ СЛОЙ (Infrastructure Layer)                 │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │      │
│  │  │ lib/prisma.ts│  │lib/auth/     │  │lib/bot/      │       │      │
│  │  │              │  │admin-auth.ts │  │handlers/     │       │      │
│  │  │ • Prisma     │  │              │  │              │       │      │
│  │  │   Client     │  │ • JWT        │  │ • Telegram   │       │      │
│  │  │              │  │   signing    │  │   Bot API    │       │      │
│  │  │              │  │ • JWT        │  │              │       │      │
│  │  │              │  │   verify     │  │              │       │      │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │      │
│  │                                                              │      │
│  │  ┌────────────────────────────────────────────────────┐     │      │
│  │  │  Внешние зависимости:                               │     │      │
│  │  │  • Turso (SQLite)                                   │     │      │
│  │  │  • Telegram Bot API                                 │     │      │
│  │  │  • Environment Variables                            │     │      │
│  │  └────────────────────────────────────────────────────┘     │      │
│  └──────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Ключевые принципы архитектуры

### 1. **Разделение ответственности (Separation of Concerns)**

```
┌─────────────────────────────────────────────────────────────┐
│  Adapters (api/*.ts)                                        │
│  • Только HTTP-специфика                                     │
│  • Разбор запросов                                           │
│  • Формирование ответов                                      │
│  • ⚠️  Легко заменить на Express/Fastify/Koa               │
└─────────────────────────────────────────────────────────────┘
                          │
                          │ ControllerResult<T>
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  Controllers (lib/controllers/*.ts)                          │
│  • Оркестрация бизнес-логики                                 │
│  • Обработка ошибок                                          │
│  • ✅ Platform-agnostic (не зависит от HTTP)                │
└─────────────────────────────────────────────────────────────┘
                          │
                          │ Service calls
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  Services (lib/services/*.ts)                               │
│  • Чистая бизнес-логика                                      │
│  • Работа с данными                                          │
│  • ✅ НЕ знает про HTTP                                      │
└─────────────────────────────────────────────────────────────┘
```

### 2. **Инверсия зависимостей (Dependency Inversion)**

```
Внешние зависимости (Vercel) → Adapters → Controllers → Services → Infrastructure
     ▲                                                              │
     │                                                              │
     └──────────────────────────────────────────────────────────────┘
                    Зависимости направлены внутрь
```

### 3. **Порты и адаптеры (Ports and Adapters)**

```
┌─────────────────────────────────────────────────────────────┐
│  PORT (Интерфейс)                                            │
│  ControllerResult<T> = { status: number, data: T }          │
└─────────────────────────────────────────────────────────────┘
                          ▲
                          │
        ┌─────────────────┴─────────────────┐
        │                                     │
┌───────▼────────┐                  ┌────────▼────────┐
│ Vercel Adapter │                  │ Express Adapter │
│ (api/*.ts)     │                  │ (routes/*.ts)   │
└────────────────┘                  └─────────────────┘
```

---

## Как заменить Vercel на Express

### Текущая реализация (Vercel):

```typescript
// api/auth.ts
export default async function handler(req: VercelRequest, res: VercelResponse) {
  const input: AdminLoginInput = req.body || {};
  const result = await loginAdmin(input);  // ← Controller (platform-agnostic)
  return res.status(result.status).json(result.data);
}
```

### Новая реализация (Express):

```typescript
// routes/auth.ts
import express from 'express';
import { loginAdmin } from '../lib/controllers/auth.controller.js';

const router = express.Router();

router.post('/api/auth', async (req, res) => {
  const input: AdminLoginInput = req.body || {};
  const result = await loginAdmin(input);  // ← Тот же Controller!
  return res.status(result.status).json(result.data);
});

export default router;
```

### Что нужно изменить:

```
┌─────────────────────────────────────────────────────────────┐
│  ❌ УДАЛИТЬ:                                                 │
│  • api/*.ts (Vercel handlers)                                │
│  • vercel.json                                               │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  ✅ ДОБАВИТЬ:                                                │
│  • routes/*.ts (Express routes)                              │
│  • server.ts (Express app)                                   │
│  • package.json (express dependency)                         │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  ✅ НЕ ТРОГАТЬ (platform-agnostic):                          │
│  • lib/controllers/*.ts                                      │
│  • lib/services/*.ts                                         │
│  • lib/types/*.ts                                            │
│  • lib/errors/*.ts                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## Основные преимущества Hexagonal Architecture

### 1. **Независимость от внешних технологий (Framework Independence)**

Бизнес-логика полностью изолирована от HTTP-фреймворков, баз данных и других внешних зависимостей. Это позволяет:

- **Легко менять платформу**: Vercel → Express → Fastify → Koa → Hono
- **Не зависеть от изменений в библиотеках**: обновление Express не затронет бизнес-логику
- **Использовать разные технологии одновременно**: часть API на Vercel, часть на Express

```
Vercel → Express → Fastify → Koa → Hono
  │         │         │        │      │
  └─────────┴─────────┴────────┴──────┘
              │
              ▼
        Controllers
        (неизменны)
```

### 2. **Тестируемость (Testability)**

Бизнес-логика тестируется без необходимости поднимать HTTP-сервер, мокать Request/Response или настраивать базу данных:

```typescript
// ✅ Легко тестировать контроллеры без HTTP
test('loginAdmin should return token', async () => {
  const result = await loginAdmin({ password: 'correct' });
  expect(result.data.ok).toBe(true);
  expect(result.data.token).toBeDefined();
});

// ✅ Легко тестировать сервисы без БД (через моки)
test('userService.create should handle duplicates', async () => {
  const mockPrisma = { user: { upsert: jest.fn() } };
  // ... тест без реальной БД
});
```

**Сравнение с MVC**: В MVC контроллеры часто тесно связаны с HTTP-запросами, что усложняет unit-тестирование.

### 3. **Переиспользуемость (Reusability)**

Один контроллер можно использовать в разных контекстах без изменений:

```typescript
// Один и тот же контроллер для разных интерфейсов:

// 1. HTTP API (Vercel/Express)
router.post('/api/auth', async (req, res) => {
  const result = await loginAdmin(req.body);
  res.status(result.status).json(result.data);
});

// 2. GraphQL resolver
const authResolver = {
  login: async (_, { password }) => {
    const result = await loginAdmin({ password });
    return result.data;
  }
};

// 3. CLI команда
const loginCommand = async (password: string) => {
  const result = await loginAdmin({ password });
  console.log(result.data.ok ? 'Успешно!' : 'Ошибка!');
};

// 4. WebSocket handler
socket.on('login', async (data) => {
  const result = await loginAdmin(data);
  socket.emit('loginResult', result.data);
});

// 5. Serverless function (AWS Lambda, Cloudflare Workers)
export const handler = async (event) => {
  const result = await loginAdmin(JSON.parse(event.body));
  return { statusCode: result.status, body: JSON.stringify(result.data) };
};
```

### 4. **Легкая миграция и эволюция (Easy Migration)**

При необходимости сменить платформу или добавить новый интерфейс:

```
Время миграции: ~30 минут
Изменения: только слой адаптеров (api/* → routes/*)
Риск: минимальный (бизнес-логика не меняется)
Тестирование: только адаптеры (контроллеры уже протестированы)
```

### 5. **Четкое разделение ответственности (Separation of Concerns)**

Каждый слой имеет одну четкую ответственность:

- **Adapters**: только преобразование форматов (HTTP → объекты, объекты → HTTP)
- **Controllers**: оркестрация и обработка ошибок
- **Services**: чистая бизнес-логика
- **Infrastructure**: работа с внешними системами

Это упрощает понимание кода, его поддержку и рефакторинг.

### 6. **Гибкость в выборе технологий (Technology Flexibility)**

Можно использовать разные технологии для разных частей приложения:

```
┌─────────────────────────────────────────┐
│  Один контроллер, разные адаптеры:      │
│                                         │
│  • HTTP API → Vercel                    │
│  • WebSocket → Socket.io                │
│  • CLI → Commander.js                   │
│  • GraphQL → Apollo Server              │
│  • gRPC → @grpc/grpc-js                 │
└─────────────────────────────────────────┘
```

### 7. **Устойчивость к изменениям (Resilience to Change)**

Изменения во внешних системах не затрагивают бизнес-логику:

- Обновление Vercel SDK → меняется только `api/*.ts`
- Смена базы данных (PostgreSQL → MongoDB) → меняется только `lib/prisma.ts`
- Добавление нового HTTP-фреймворка → добавляется новый адаптер, контроллеры не меняются

---

## Почему выбрали Hexagonal Architecture?

### 1. **Неопределенность платформы**

На начальном этапе проекта не было ясности, какая платформа будет использоваться в долгосрочной перспективе:
- Vercel удобен для быстрого старта и деплоя
- Express может понадобиться для более сложных сценариев
- Serverless функции могут быть выгоднее при росте нагрузки

**Решение**: Hexagonal Architecture позволяет начать с Vercel, но легко перейти на другую платформу при необходимости.

### 2. **Множественные интерфейсы**

Приложение должно поддерживать:
- HTTP API для веб-приложения
- Telegram Bot API (webhook)
- Возможно, CLI для администрирования в будущем

**Решение**: Один контроллер используется разными адаптерами, что исключает дублирование бизнес-логики.

### 3. **Тестируемость как приоритет**

Важно было обеспечить высокое покрытие тестами без сложной настройки инфраструктуры.

**Решение**: Контроллеры и сервисы тестируются изолированно, без HTTP-сервера и реальной БД.

### 4. **Долгосрочная поддерживаемость**

Проект должен легко поддерживаться и развиваться, даже если команда изменится.

**Решение**: Четкое разделение слоев делает код понятным и предсказуемым для новых разработчиков.

### 5. **Готовность к масштабированию**

При росте проекта может потребоваться:
- Микросервисная архитектура
- Разные технологии для разных сервисов
- Интеграция с новыми системами

**Решение**: Hexagonal Architecture упрощает разделение на микросервисы и интеграцию новых систем.

---

## Сравнение с популярными архитектурами

### Hexagonal Architecture vs MVC

#### MVC (Model-View-Controller)

```
┌─────────────┐
│   View      │ ← Отображение (UI)
└──────┬──────┘
       │
┌──────▼──────┐
│ Controller  │ ← Обработка запросов
└──────┬──────┘
       │
┌──────▼──────┐
│   Model     │ ← Данные и бизнес-логика
└─────────────┘
```

**Особенности MVC:**
- Контроллеры часто зависят от HTTP-фреймворка
- Модели могут содержать и данные, и бизнес-логику
- Предназначена в первую очередь для веб-приложений с UI

**Пример MVC (Express):**
```typescript
// ❌ Контроллер зависит от Express
router.post('/auth', async (req: Request, res: Response) => {
  // Бизнес-логика смешана с HTTP-обработкой
  if (req.body.password !== process.env.ADMIN_PASSWORD) {
    return res.status(401).json({ error: 'Неверный пароль' });
  }
  const token = jwt.sign({ admin: true }, process.env.SECRET);
  return res.json({ token });
});
```

#### Hexagonal Architecture

```
┌─────────────────┐
│  HTTP Adapter   │ ← Только HTTP-специфика
└────────┬────────┘
         │
┌────────▼────────┐
│   Controller    │ ← Platform-agnostic
└────────┬────────┘
         │
┌────────▼────────┐
│    Service      │ ← Чистая бизнес-логика
└─────────────────┘
```

**Пример Hexagonal:**
```typescript
// ✅ Контроллер не зависит от Express
export async function loginAdmin(input: AdminLoginInput) {
  // Чистая бизнес-логика
  if (input.password !== getAdminPassword()) {
    throw new UnauthorizedError('Неверный пароль');
  }
  const token = signAdminToken(getAdminSecret());
  return { status: 200, data: { ok: true, token } };
}

// ✅ Адаптер - тонкий слой
router.post('/auth', async (req, res) => {
  const result = await loginAdmin(req.body);
  res.status(result.status).json(result.data);
});
```

**Ключевые отличия:**

| Аспект | MVC | Hexagonal Architecture |
|--------|-----|------------------------|
| **Зависимость от фреймворка** | Контроллеры зависят от HTTP | Контроллеры независимы |
| **Тестируемость** | Требует моков HTTP | Тестируется без HTTP |
| **Переиспользование** | Сложно использовать вне веба | Легко использовать в разных контекстах |
| **Миграция платформы** | Требует переписывания контроллеров | Меняются только адаптеры |
| **Разделение логики** | Модели могут смешивать данные и логику | Четкое разделение слоев |

---

### Hexagonal Architecture vs MVVM

#### MVVM (Model-View-ViewModel)

```
┌─────────────┐
│    View     │ ← UI (React, Vue, Angular)
└──────┬──────┘
       │ Data Binding
┌──────▼──────┐
│ ViewModel   │ ← Презентационная логика
└──────┬──────┘
       │
┌──────▼──────┐
│   Model     │ ← Данные и бизнес-логика
└─────────────┘
```

**Особенности MVVM:**
- Предназначена для клиентских приложений (SPA, мобильные)
- ViewModel связывает View и Model через data binding
- Фокус на реактивности и синхронизации состояния

**Пример MVVM (React + MobX):**
```typescript
// ViewModel
class AuthViewModel {
  @observable password = '';
  @observable error = '';
  
  @action
  async login() {
    try {
      const response = await fetch('/api/auth', {
        method: 'POST',
        body: JSON.stringify({ password: this.password })
      });
      const data = await response.json();
      // Обновление состояния для View
      this.token = data.token;
    } catch (err) {
      this.error = err.message;
    }
  }
}

// View
const LoginView = observer(() => {
  const vm = new AuthViewModel();
  return (
    <input value={vm.password} onChange={e => vm.password = e.target.value} />
    <button onClick={() => vm.login()}>Войти</button>
  );
});
```

#### Сравнение с Hexagonal Architecture

**MVVM** и **Hexagonal Architecture** решают разные задачи:

| Аспект | MVVM | Hexagonal Architecture |
|--------|------|------------------------|
| **Область применения** | Клиентские приложения (Frontend) | Серверные приложения (Backend) |
| **Основная задача** | Синхронизация UI и данных | Изоляция бизнес-логики от инфраструктуры |
| **Data Binding** | Ключевая особенность | Не применимо |
| **Зависимости** | Зависит от UI-фреймворка | Независим от платформы |
| **Тестируемость** | Требует моков UI | Тестируется без инфраструктуры |

**Важно**: MVVM и Hexagonal Architecture **не конкурируют**, а **дополняют друг друга**:

```
┌─────────────────────────────────────────────────┐
│  Frontend (MVVM)                                 │
│  ┌─────────┐  ┌──────────┐  ┌─────────┐      │
│  │  View   │  │ ViewModel │  │  Model  │      │
│  └────┬────┘  └─────┬─────┘  └────┬────┘      │
└───────┼──────────────┼─────────────┼───────────┘
        │              │             │
        │              │ HTTP        │
        │              ▼             │
┌───────┼────────────────────────────┼───────────┐
│       │  Backend (Hexagonal)        │           │
│       │  ┌──────────┐  ┌──────────┐│           │
│       │  │ Adapter  │  │Controller││           │
│       │  └────┬─────┘  └────┬─────┘│           │
│       │       │              │      │           │
│       │       │              ▼      │           │
│       │       │       ┌──────────┐  │           │
│       │       │       │ Service  │  │           │
│       │       │       └──────────┘  │           │
│       └───────┴─────────────────────┘           │
└─────────────────────────────────────────────────┘
```

**В нашем проекте:**
- **Frontend** (React) может использовать MVVM-подход для управления состоянием
- **Backend** использует Hexagonal Architecture для изоляции бизнес-логики

---

## Когда использовать каждую архитектуру?

### MVC — подходит для:
- ✅ Простые веб-приложения с четким разделением UI и логики
- ✅ Быстрое прототипирование
- ✅ Приложения, где платформа не будет меняться
- ❌ Не подходит, если нужна гибкость в выборе платформы

### MVVM — подходит для:
- ✅ Клиентские SPA-приложения (React, Vue, Angular)
- ✅ Приложения с сложным состоянием UI
- ✅ Требуется реактивность и data binding
- ❌ Не применимо для серверной части

### Hexagonal Architecture — подходит для:
- ✅ Серверные приложения с множественными интерфейсами
- ✅ Когда платформа может измениться
- ✅ Высокие требования к тестируемости
- ✅ Долгосрочные проекты с требованиями к масштабируемости
- ✅ Микросервисная архитектура
- ❌ Может быть избыточна для простых CRUD-приложений

---

## Структура файлов

```
Lamda_Integral/
├── api/                          ← 🔄 ЗАМЕНИМЫЙ СЛОЙ (Adapters)
│   ├── auth.ts                   ← Vercel HTTP handler
│   ├── users.ts                  ← Vercel HTTP handler
│   └── bot.ts                    ← Vercel HTTP handler
│
├── lib/
│   ├── controllers/              ← ✅ НЕЗАВИСИМЫЙ СЛОЙ (Ports)
│   │   ├── auth.controller.ts    ← Platform-agnostic
│   │   └── user.controller.ts    ← Platform-agnostic
│   │
│   ├── services/                 ← ✅ ДОМЕННЫЙ СЛОЙ (Domain)
│   │   ├── auth.service.ts       ← Бизнес-логика
│   │   ├── user.service.ts       ← Бизнес-логика
│   │   └── telegram-auth.service.ts
│   │
│   ├── errors/                   ← ✅ ДОМЕННЫЕ ОШИБКИ
│   │   └── app.errors.ts
│   │
│   ├── types/                    ← ✅ ТИПЫ
│   │   └── *.types.ts
│   │
│   ├── prisma.ts                 ← 🔧 ИНФРАСТРУКТУРА
│   └── auth/                     ← 🔧 ИНФРАСТРУКТУРА
│       └── admin-auth.ts
│
└── vercel.json                   ← 🔄 КОНФИГУРАЦИЯ VERCEL
```

---

## Заключение

Архитектура бэкенда построена по принципам **Hexagonal Architecture (Ports and Adapters)**, что обеспечивает:

✅ **Независимость от платформы** - бизнес-логика не зависит от HTTP-фреймворка  
✅ **Легкую замену адаптеров** - переход с Vercel на Express займет ~30 минут  
✅ **Тестируемость** - контроллеры и сервисы тестируются без HTTP  
✅ **Переиспользуемость** - один контроллер для разных интерфейсов  
✅ **Поддерживаемость** - четкое разделение ответственности  

**Ключевой принцип**: Внешние зависимости (Vercel, Express) зависят от внутренних слоев (Controllers, Services), а не наоборот.

